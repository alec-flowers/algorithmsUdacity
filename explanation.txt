Problem 1 - Square Root of an Integer
Design Choices
The formula is :
x(n+1) = x(n) - f(x(n))/f'(x(n)) = 1/2 (x(n)+a/(x(n))). This is the arithmetic mean of x(n) and a/x(n). The basic idea being if x(n) > sqrt(a) then a/x(n) < sqrt(a) so the arithmetic mean will get us a better estimate. 

Time Complexity
N = range(1,number) - The brute force solution would be iterating starting from 1 up to the number and calculating the square. I would classify this as O(N) time.
O(log(N))

Space Complexity
O(1) - I do not create any additional data structures. I just have one variable x that I set the input to. 


Problem 2 - Search a Rotated Sorted Array
Design Choices
To search a normal sorted array in log n time you would use binary search which cuts your search space in half every iteration.
I knew then that this would just be a modified version of binary search. The trick here is to know where the pivot in the array is.
You can figure this out by checking if the first element in the array greater than the middle element. If so you know that the pivot
occured in the left part of the array and that the right side of the array is "sorted". 

Time Complexity
N = number of items in initial array
O(Log N)
Since we use binary search we cut the search space in half by a factor of 2. This is Log N time complexity. 

Space Complexity
O(1)
We don't create any additional data structures as we just keep track of indices in the arrray. 


Problem 3 - Rearrange Array Elements
Design Choices
The first way to solve this would be to sort the array and then fill in your numbers using the sorted array. I figured I could
speed up the time complexity since we know there is a limit [0, 9]. I can iterate through the array and count the frequencies of 
numbers and use this to create the two numbers to be summed. 

Time Complexity
N = number of elements in array
O(N)
I iterate through the array once to get the frequencies and then iterate through one more time to unwind the frequencies and turn
it into numbers. 

Space Complexity
N = number of elements in array
O(N)
I create one additional array to count the frequencies. 


Problem 4 - Dutch National Flag Problem
Design Choices
I keep track of where in the array I need to place the Os and 2s. Once you've sorted these the 1's are also sorted in the same place. 

Time Complexity
N = number of elements in array
O(N)
Iterate through the array one time. 

Space Complexity
O(1)
Modifing the array in place so no additional data structures are created.


Problem 5 - Autocomplete with Tries
Design Choices
Regarding the suffixes class - had to build this recursively in the TrieNode() class. The part I found difficult was how to pass through
the list of items that could possibly be suffixes. In python if I use a mutable default argument and mutate it, then I have the
mutated object for all future calls which messes up future suffix calls. I jumped around this by using a default call and checking for 
it with an if statement. 

Time Complexity
Building a Trie
m = length of longest word
n = total number of words
O(m*n)

Insertion
a = length of word
n = total number of words
O(a*n)

Space Complexity
k = footprint of single node
n = number of nodes
O(k*n)


Problem 6 - Max & Min in an unsorted Array
Design Choices
Iterated over the array with a tracker that compares each value against a max and min and swaps the value if it is a new max or min.

Time Complexity
N = number of items in array
O(N)
We have to check in the worst case every element in the array.

Space Complexity
O(1)
Created two ints to keep track of max and min but nothing else. 


Problem 7 - Request Routing in a Web Server with a Trie
Time Complexity
Building a Trie
m = length of longest path
n = total number of paths
O(m*n)

Insertion
a = length of path
n = total number of paths
O(a*n)

Space Complexity
k = footprint of single node
n = number of nodes
O(k*n)